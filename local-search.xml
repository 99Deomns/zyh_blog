<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/zyh_blog/2025/09/20/hello-world/"/>
    <url>/zyh_blog/2025/09/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vscode配置文件</title>
    <link href="/zyh_blog/2025/09/20/vscode%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/zyh_blog/2025/09/20/vscode%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="vscode配置文件"><a href="#vscode配置文件" class="headerlink" title="vscode配置文件"></a>vscode配置文件</h2><p><a href="https://developer.aliyun.com/article/1477755">VSCode上搭建C&#x2F;C++开发环境（vscode配置c&#x2F;c++环境）Windows系统—保姆级教程-阿里云开发者社区</a></p><p><a href="https://blog.csdn.net/realDonaldTrump/article/details/78001882?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-78001882-blog-134442270.235%5Ev43%5Epc_blog_bottom_relevance_base4&spm=1001.2101.3001.4242.3&utm_relevant_index=6">Windows下配置VSCode编译&#x2F;调试C&#x2F;C++：launch.json配置_vscod launch.json没有gdb配置-CSDN博客</a></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bat">task.json //用来配置任务，可以直接执行不同的任务，下面就有两个任务，第一个生成了exe文件，第二个打印当前目录的fileDirname<br>//E:\Desktop\C\test1\test.cpp<br>&#123;<br>&quot;version&quot;: &quot;<span class="hljs-number">2</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>&quot;,<br>&quot;tasks&quot;: [<br>&#123;<br>&quot;<span class="hljs-built_in">type</span>&quot;: &quot;cppbuild&quot;,<br>&quot;<span class="hljs-built_in">label</span>&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;,<br>&quot;command&quot;: &quot;G:\\x86_64-<span class="hljs-number">15</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>-release-win32-seh-ucrt-rt_v13-rev0\\mingw64\\bin\\g++.exe&quot;,<br>&quot;args&quot;: [<br>&quot;-fdiagnostics-<span class="hljs-built_in">color</span>=always&quot;,<br>&quot;-g&quot;,<br>&quot;test1\\test.cpp&quot;, //这里最好还是用绝对路径，否则如果不在E:\Desktop\C这个路径下运行那就搜不到这个文件<br>&quot;-o&quot;,<br>&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot; //这里的$&#123;fileDirname&#125;是当前目录，<br>//$&#123;fileBasenameNoExtension&#125;是当前文件，详细说明见图一<br>// &quot;a.exe&quot;<br>],<br>&quot;options&quot;: &#123;<br>// &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;<br>&quot;cwd&quot;: &quot;E:\\Desktop\\C&quot;<br>&#125;,<br>&quot;problemMatcher&quot;: [<br>&quot;$gcc&quot;<br>],<br>&quot;group&quot;: &quot;build&quot;,<br>&quot;detail&quot;: &quot;编译器: G:\\x86_64-<span class="hljs-number">15</span>.<span class="hljs-number">2</span>.<span class="hljs-number">0</span>-release-win32-seh-ucrt-rt_v13-rev0\\mingw64\\bin\\g++.exe&quot;<br>&#125;,<br>        &#123;//注意这里的fileDirname是在哪里执行的就是哪个文件的文件夹见图二<br>            &quot;<span class="hljs-built_in">label</span>&quot;: &quot;输出fileDirname&quot;,<br>            &quot;<span class="hljs-built_in">type</span>&quot;: &quot;shell&quot;,<br>            &quot;command&quot;: &quot;<span class="hljs-built_in">echo</span> $&#123;fileDirname&#125;&quot;,<br>            &quot;group&quot;: &quot;none&quot;<br>        &#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><p>ctrl+shift+p 运行任务，然后就是代码块中的两个任务选</p><p><img src="/zyh_blog/zyh_blog/2025/09/20/vscode%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/Blog\source_posts\vscode配置文件\1.png"></p><center>图1 在task.json文件下运行任务</center><p>此时生成了task.exe，但实际上他就是test.cpp编译好的文件但是由于13行给他定义了文件名称和路径，如果在test.cpp文件下运行任务最后就是在test1文件夹下生成了test.exe文件，总之都是自己定义的；</p><p><img src="/zyh_blog/zyh_blog/2025/09/20/vscode%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/Blog\source_posts\vscode配置文件\2.png"></p><center>图2</center><p><img src="/zyh_blog/zyh_blog/2025/09/20/vscode%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/Blog\source_posts\vscode配置文件\3.png"></p><center>图 3 </center>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/zyh_blog/2025/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/zyh_blog/2025/09/20/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>一个类只会生成一个实例，避免生成太多占用系统资源，需要将构造函数放在private中，同时还有拷贝构造函数也需要放在private中，在调用时需要静态成员函数传出实例，单例模式有两种：饿汉和懒汉；</p><p>问题：为什么要用静态成员函数和静态成员？<br>因为只有一个实例，同时生命周期又不能和对象一样，要和程序运行时间一样，所以需要用静态成员；而如果不使用静态成员函数，就必须要有一个对象才能调用getinstance函数，就矛盾了，所以还是得用static；</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>饿汉：只有要用到才实例化，详见代码，但是下面这种方式在多线程中不安全，如果多个线程同时走进getinstance的话，可能会创建多个实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*单例模式：构造函数私有化，对外提供一个接口*/</span><br> <br><span class="hljs-comment">//线程不安全的懒汉模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">singleClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">static</span> singleClass* <span class="hljs-title">getinstance1</span><span class="hljs-params">()</span><span class="hljs-comment">//对外的接口（方法），静态成员函数调用静态成员变量</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>)<br>&#123;<br>instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">singleClass</span>();<br>&#125;<br><span class="hljs-keyword">return</span> instance;<br>&#125;;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> singleClass* instance;<span class="hljs-comment">//静态成员变量，类内声明，类外初始化</span><br><span class="hljs-built_in">singleClass</span>() &#123;&#125; <span class="hljs-comment">//构造函数属性设置为私有</span><br> <br>    <span class="hljs-built_in">singleClass</span>(<span class="hljs-type">const</span> singleClass &amp; sc) &#123;&#125; <span class="hljs-comment">//拷贝构造函数也需要设置为私有</span><br>&#125;;<br>singleClass* singleClass::instance=<span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//初始化静态变量</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//懒汉模式</span><br>singleClass* singlep1=singleClass::<span class="hljs-built_in">getinstanc1</span>();<span class="hljs-comment">//通过类域获取接口</span><br>singleClass* singlep2 = singleClass::<span class="hljs-built_in">getinstanc1</span>();<br> <br>    cout &lt;&lt; singlep1 &lt;&lt; endl;<br>cout &lt;&lt; singlep2 &lt;&lt; endl;<br> <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>饿汉模式2：使用线程锁，进去后再次判断，保障了线程安全；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;mutex&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*单例模式：构造函数私有化，对外提供一个接口*/</span><br> <br><span class="hljs-comment">//线程安全的单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">lhsingleClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">static</span> lhsingleClass* <span class="hljs-title">getinstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//双重锁模式</span><br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>)<br>&#123;<span class="hljs-comment">//先判断是否为空，如果为空则进入，不为空说明已经存在实例，直接返回</span><br>            <span class="hljs-comment">//进入后加锁</span><br>i_mutex.<span class="hljs-built_in">lock</span>();<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>)<br>&#123;<span class="hljs-comment">//再判断一次，确保不会因为加锁期间多个线程同时进入</span><br>instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">lhsingleClass</span>();<br>&#125;<br>i_mutex.<span class="hljs-built_in">unlock</span>();<span class="hljs-comment">//解锁</span><br>&#125;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> lhsingleClass* instance;<br><span class="hljs-type">static</span> mutex i_mutex;<span class="hljs-comment">//锁</span><br><span class="hljs-built_in">lhsingleClass</span>()&#123;&#125;<br>    <span class="hljs-built_in">lhsingleClass</span>(<span class="hljs-type">const</span> lhsingleClass&amp; sc) &#123;&#125;<span class="hljs-comment">//拷贝构造函数也需要设置为私有</span><br>&#125;;<br>lhsingleClass* lhsingleClass::instance=<span class="hljs-literal">nullptr</span>;<br>mutex lhsingleClass::i_mutex;<span class="hljs-comment">//类外初始化</span><br> <br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>lhsingleClass* lhsinglep5 = lhsingleClass::<span class="hljs-built_in">getinstance</span>();<br>lhsingleClass* lhsinglep6 = lhsingleClass::<span class="hljs-built_in">getinstance</span>();<br> <br>cout &lt;&lt; lhsinglep5 &lt;&lt; endl;<br>cout &lt;&lt; lhsinglep6 &lt;&lt; endl;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>懒汉模式：在类外就直接创建了，后续的getinstance都是为了获取唯一实例的指针；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*单例模式：构造函数私有化，对外提供一个接口*/</span><br> <br><span class="hljs-comment">//饿汉模式：不管用不用得到，都构造出来。本身就是线程安全的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ehsingleClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> ehsingleClass* <span class="hljs-title">getinstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> ehsingleClass* instance;<span class="hljs-comment">//静态成员变量必须类外初始化，只有一个</span><br><span class="hljs-built_in">ehsingleClass</span>() &#123;&#125;<br>&#125;;<br>ehsingleClass* ehsingleClass::instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ehsingleClass</span>();<br><span class="hljs-comment">//类外定义，main开始执行前，该对象就存在了</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//饿汉模式</span><br>ehsingleClass* ehsinglep3 = ehsingleClass::<span class="hljs-built_in">getinstance</span>();<br>ehsingleClass* ehsinglep4 = ehsingleClass::<span class="hljs-built_in">getinstance</span>();<br><span class="hljs-comment">//ehsingleClass* ehsinglep5 = ehsingleClass::get();//非静态成员方法必须通过对象调用，不能通过类域访问</span><br> <br>cout &lt;&lt; ehsinglep3 &lt;&lt; endl;<br>cout &lt;&lt; ehsinglep4 &lt;&lt; endl;<br> <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>待学清单</title>
    <link href="/zyh_blog/2025/09/20/%E5%BE%85%E5%AD%A6%E6%B8%85%E5%8D%95/"/>
    <url>/zyh_blog/2025/09/20/%E5%BE%85%E5%AD%A6%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="待学清单"><a href="#待学清单" class="headerlink" title="待学清单"></a>待学清单</h2><p>1.模板</p><p>2.类的多态</p><p>3.build.gn文件，总结vscode的task文件；</p><p>4.线程锁、条件变量</p><p>5.单例模式</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态成员与静态成员函数</title>
    <link href="/zyh_blog/2025/09/20/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <url>/zyh_blog/2025/09/20/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="静态成员与静态成员函数"><a href="#静态成员与静态成员函数" class="headerlink" title="静态成员与静态成员函数"></a><strong>静态成员与静态成员函数</strong></h1><h2 id="1-static关键字"><a href="#1-static关键字" class="headerlink" title="1 static关键字"></a>1 static关键字</h2><p>静态成员，静态成员属于class本身而不属于其对象;    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<span class="hljs-comment">//普通成员变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> nums;<span class="hljs-comment">//静态成员变量</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>; <span class="hljs-comment">//静态成员函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//三种调用静态成员函数的方式</span><br>        <span class="hljs-built_in">print</span>();<br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">print</span>();<br>        person::<span class="hljs-built_in">print</span>();<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">person::print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-comment">//静态成员函数只能访问静态成员，否则会报错</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;static function print().&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-type">int</span> person::nums = <span class="hljs-number">10</span>;<span class="hljs-comment">//这里是给nums赋值就不能使用static了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;person::nums&lt;&lt;endl; <span class="hljs-comment">//调用方式1</span><br>    person p1;<br>    cout&lt;&lt;p<span class="hljs-number">1.</span>nums&lt;&lt;endl;<span class="hljs-comment">//调用方式2</span><br>    p<span class="hljs-number">1.f</span>un();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从内存角度上看，class只是定义一种类型，并不定义变量和对象，所以静态成员的真正定义是在外部，类似于全局变量。静态成员变量不占用对象的存储空间，存放在全局变量空间中；</p><p>从生命周期上看，静态成员和静态成员函数的生命周期都是是程序加载时被落实到内存中，程序结束时死亡，类似于全局函数；</p><p>普通成员和对象是绑定的生命周期等同于对象的生命周期；  </p><h2 id="2-用途"><a href="#2-用途" class="headerlink" title="2 用途"></a>2 用途</h2><p>静态成员常用于统计到底有多少个对象的存在，下面是一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<span class="hljs-comment">//普通成员变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> nums;<span class="hljs-comment">//静态成员变量</span><br><span class="hljs-built_in">person</span>()&#123;person::nums++;&#125;<br>~<span class="hljs-built_in">person</span>()&#123;person::nums--;&#125;<br>&#125;;<br><span class="hljs-type">int</span> person::nums = <span class="hljs-number">0</span>;<span class="hljs-comment">//通过对象除了要在类外定义</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>**argv)</span></span><br><span class="hljs-function"></span>&#123;<br>person a,b,c;<br>cout&lt;&lt;person::nums&lt;&lt;endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/zyh_blog/zyh_blog/2025/09/20/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/1.png"></p><p><img src="/zyh_blog/zyh_blog/2025/09/20/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/image-20250920233723535.png" alt="image-20250920233723535"></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
